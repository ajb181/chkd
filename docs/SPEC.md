# chkd v2 Specification

> Organized by **system area** rather than build phase.
> The spec is both the todo list and the map of what exists.

<!-- âš ï¸ CLAUDE: Do NOT edit this file directly! Use chkd CLI commands:
     - chkd add "feature" - Add new items
     - chkd tick "item"   - Mark items complete
     - chkd working "item" - Mark items in-progress
     This keeps the UI in sync and tracks changes properly. -->

---

## Overview

**chkd** is a development workflow system that makes AI-assisted development structured and consistent.

**Core idea**: Plan in one place (UI), build in another (terminal). The spec is the source of truth.

---

## Site Design

> How chkd looks and feels. Pages, layouts, user flows.

### Pages

#### Guide (`/guide`)
How to use chkd - workflow explanation, commands, troubleshooting.

**Status**: Docs exist, UI page needed
- [x] **SD.1 Guide Documentation** - docs/GUIDE.md created
- [x] **SD.2 Guide Page** - Svelte page at /guide route
  - [x] Workflow diagram
  - [x] Session lifecycle visual
  - [x] Quick reference cards
  - [x] Troubleshooting section

#### Command Center (`/`)
The main workspace. Shows current task, story list, progress.

**Status**: Not started
- [x] **SD.3 Command Center Layout** - Main page structure
  - [x] Current task card (pinned at top)
  - [x] Story list sidebar
  - [x] Story detail panel
  - [x] Progress overview

#### Settings (`/settings`)
Configure repos and preferences.

**Status**: Not started
- [x] **SD.4 Settings Page** - Basic settings
  - [x] Repository path configuration
  - [x] Theme toggle (dark/light)

### Design System

- [x] **SD.5 CSS Variables** - Color system, spacing, typography
- [x] **SD.6 Component Styles** - Buttons, cards, inputs
- [x] **SD.7 Dark Mode** - Full dark theme support
- [x] **SD.8 Queue List for Off-Task Items** - Capture todos during active session, surface on tick with instructions for Claude to add to internal todo
  - [x] Queue input in task card (visible during active session)
  - [x] Queued item count badge
  - [x] Remove items before tick
  - [x] POST /api/session/queue - Add item
  - [x] GET /api/session/queue - List items
  - [x] DELETE /api/session/queue/:id - Remove item
  - [x] Update tick response to include queued items + instructions
  - [x] Auto-clear queue after surfacing
- [x] **SD.11 Can we add a task to replace the drop-down menu for swapping the repose I'm imagining a set of cards that run across the top they have a bit of information about the repo and what's developing where it's at like a very condensed high-level and you can click between them really easily and they're showing you what each one's working on at the moment or if it's idle** - The cards will run across the top of the screen, displaying details like the repository name, what's currently being developed, and the overall status.

> As a product manager, I want a set of cards that show high-level information about each repository so that I can easily see what's being worked on and the status of each area. You can click them to nav between them
  - [x] Explore: understand problem, search existing functions
  - [x] Design: flow diagram if needed
  - [x] Prototype: backend with test data + frontend calling it
  - [x] Feedback: user reviews prototype
  - [x] Implement: replace test data with real logic
  - [x] Polish: iterate based on usage
  - [x] Allow quick message to the queue that gets pulled in on the next "click"
  - [x] Add ability to receive a message when Claude asked multi questions and is blocking to continue you could handle it in the app
  - [x] Connect blocking questions UI to embedded terminal (after SD.12)
- [x] **SD.12 Embedded Terminal** - Add xterm.js terminal to chkd UI with tmux backend for session persistence. Can run Claude Code directly in the web app, survives page refresh, can also attach from regular terminal.
  - [x] Explore: xterm.js, node-pty, tmux integration
  - [x] Design: terminal panel layout in UI
  - [x] Prototype: xterm.js + WebSocket + node-pty
  - [x] Add tmux session management (create/attach/reattach)
  - [x] Handle page refresh reconnection
  - [x] Polish: resize handling, styling, keyboard shortcuts
  - [!] Future: Connect blocking questions API to terminal events
  - [!] Fix terminal overflow/cropping issue (tmux status bar leaks outside container)
- [x] **SD.13 add instrcutions into the Philosophy to use for bug fix when getting bugs, add apply to size the bug big or small using different approaches** - The feature will allow developers to include instructions in the Philosophy section of the application to provide guidance on how to approach and fix bugs, as well as provide tools to help assess the size and complexity of the bug.

> As a developer, I want to be able to add instructions into the Philosophy section to help with bug fixes, and be able to apply different approaches to size the bug as small or large, so that I can more effectively resolve issues.
  - [x] Explore: understand problem, search existing functions
  - [ ] Design: flow diagram if needed
  - [x] Prototype: backend with test data + frontend calling it
  - [x] Feedback: user reviews prototype
  - [ ] Implement: replace test data with real logic
  - [ ] Polish: iterate based on usage
- [x] **SD.14 Can we add a list somewhere of quick wins I think maybe on the card you can click in it just opens similar to bugs and you can just bang it in there and you can tell the AI just took it through the quick wins** - The quick wins list should be accessible from the card view, allowing users to easily log and view items that can be quickly addressed.

> As a user, I want a quick wins list that I can easily access and add to, so that I can quickly capture and surface potential improvements.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [x] **Track and display time spent on each checklist item - store duration when ticked, show in UI**
  - [x] Explore: check existing checklist data structure + timing patterns
  - [x] Design: duration storage schema + UI display mockups
  - [~] Prototype: timer UI + mock duration data display
  - [ ] Feedback: user tests timing UX and display format
  - [ ] Implement: real duration tracking + database storage
  - [ ] Polish: pause/resume states + duration formatting
- [x] **FE Terminal WebSocket connection - investigate why terminal shows disconnected and fix**
  - [x] Explore: check WebSocket connection logs and existing terminal code
  - [x] Design: identify connection failure points and reconnection strategy
  - [x] Prototype: test WebSocket with mock terminal data
  - [x] Feedback: verify connection stability in test environment
  - [x] Implement: fix connection issues and add proper error handling
  - [x] Polish: add connection status indicators and auto-reconnect
- [x] **SD.16 allow a file to be added into a bug or sotry** - Enable users to attach files (documents, images, logs, etc.) to bug reports and stories for better context and documentation.

> As a developer, I want to attach files to bugs and stories so that I can provide additional context like screenshots, logs, or documentation.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [x] **SD.17 add impromptu and debug work states so the UI is always engaged regardless** - At the moment it can be idle in the app but actually the code is working so we're looking to solve those solutions both when in debug and impromptu work

> As a developer, I want impromptu and debug work states so that the UI stays engaged during all types of work sessions.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] review overall code around this update for simplification if possible
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [x] **SD.18 allow file to be attached when creating bug or story** - Enable users to attach files (documents, images, logs, etc.) to bug reports and user stories for better context and documentation.

> As a developer, I want to attach files to bugs and stories so that I can provide additional context like screenshots, logs, or documentation.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [x] **SD.19 Update the brand homepage** - > As a website visitor, I want to see an updated brand homepage so that I get the latest information about the company and its offerings.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [x] **SD.20 add most recent adds to the spec & most recent acchieved** - Display the most recently added items and recently completed/achieved features prominently in the specification interface.

> As a developer, I want to see recent additions and achievements in the spec so that I can quickly track progress and stay updated on latest changes.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
- [ ] **SD.21 AI Prompt Studio - View, edit, version, and test all LLM prompts** - As a user, I want to see and edit all AI prompts used in chkd so that I can customize how the AI generates content and have full transparency and control. Based on Strateo's proven AI Studio architecture with version control, testing, and audit trails.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **SD.22 World-Class User Guide - Searchable, production-ready documentation for all user levels** - Complete overhaul of the chkd guide to be world-class, searchable, and production-ready for public launch.
  - [x] Research: Best practices for developer documentation and user guides
  - [x] Research: Review all spec docs, research docs, and codebase - build product knowledge doc
  - [x] Design: Guide structure and information architecture
  - [ ] Implement: Searchable documentation system
  - [ ] Write: New user journey (install, first run, quick start)
  - [ ] Write: Active user guide (daily workflows, features, customization)
  - [ ] Write: Power user guide (multi-worker, MCP tools, advanced features)
  - [ ] Write: Team/SaaS setup guide (team management, enterprise features)
  - [ ] Polish: Troubleshooting, FAQ, and edge cases
  - [ ] Review: Final quality check and user testing

**User Journey Coverage:**
- ðŸ†• New User: Installation, first run, core concepts, quick start
- ðŸ‘¤ Active User: Daily workflows, features, customization, settings
- âš¡ Power User: Multi-worker system, MCP tools, advanced features
- ðŸ‘¥ Team Lead: SaaS setup, team management, enterprise features

**Key Requirements:**
1. Research best practices for developer documentation and user guides
2. Review all spec docs, research docs, and codebase for complete product understanding
3. Searchable documentation (consider Algolia, local search, or built-in)
4. Production-ready for someone to pickup, install, and run
5. Include SaaS setup as complete (verify at launch)
6. Consider user evolution from beginner to expert

**Deliverables:**
- Comprehensive GUIDE.md or guide system
- Quick start guide (5-minute setup)
- Feature reference by user level
- Troubleshooting section
- SaaS/Team setup guide
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **SD.23 Multi-Worker System Integration Testing** - As a developer, I want to validate the multi-worker system works end-to-end so that we can confidently use parallel workers for feature development.

**Acceptance Criteria:**
- [ ] Can spawn a worker from the dashboard
- [ ] Worker Claude can claim the task
- [ ] Worker sends heartbeats visible in UI
- [ ] Worker completes and auto-merges (clean case)
- [ ] Conflict resolution works when workers touch same files
- [ ] Dead worker detection fires when worker stops sending heartbeats
- [ ] Manager signals appear in UI for all events
- [ ] Two workers can run in parallel without issues
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
---

## Frontend

> Svelte components, stores, client-side logic.

### Core Components

#### CurrentTaskCard
Shows active task status, progress, actions.

**Status**: Not started

#### StoryList
Collapsible list of areas and stories.

**Status**: Complete
- [x] **FE.2 StoryList Component**
  - [x] Area grouping (expandable)
  - [x] Story selection
  - [x] Progress percentages
  - [x] Status indicators

#### StoryDetail
Full story view with checklist.

**Status**: Complete
- [x] **FE.3 StoryDetail Component**
  - [x] User story display
  - [x] Checklist rendering
  - [x] Item status toggling
  - [x] Description/notes

#### FeatureCapture
Add new features to the spec.

**Status**: Not started
- [x] **FE.4 FeatureCapture Component**
  - [x] Feature title input
  - [x] Area selection (Site Design / Frontend / Backend)
  - [x] Workflow template auto-added
  - [x] Duplicate detection

### State Management

- [x] **FE.5 Stores** - Svelte stores for app state
  - [x] Session state
  - [x] Spec data
  - [x] UI preferences

### Client API

- [x] **FE.6 API Client** - Functions to call backend
  - [x] Fetch wrapper with error handling
  - [x] Type-safe responses
- [x] **FE.7 Allow to set tags and priority when creating a story and it's tasks** - This feature will allow users to add tags and set priority levels for stories and tasks, enabling more efficient task management and organization.

> As a user, I want to be able to set tags and priority when creating a story and its tasks so that I can better organize and prioritize my work.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
    - [ ] Add tags property to SpecItem interface
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [!] **FE.8 Redesign how the terminal fits into the app UI I think it should be 50-50 columns with the work list to fill that column currently at sort of floating or something** - Currently the terminal appears to be floating. Should be restructured as a proper column layout sharing space equally with the work list. BLOCKED: tmux status bar overflow/cropping not fully resolved, need different approach.

> As a developer, I want the terminal and work list in a 50-50 column layout so that I can efficiently view both simultaneously without overlapping UI elements.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [!] Polish: overflow/cropping issue with tmux status bar needs different approach
- [x] **FE.9 Remove terminal from UI** - Delete embedded terminal code and button from dashboard

> As a developer, I want to remove the unused terminal feature so the codebase is cleaner

**Key requirements:**
- Remove terminal button from nav
- Remove terminal panel from main area
- Remove terminal state and imports
- Remove terminal CSS styles

**Files to change:**
- src/routes/+page.svelte

**Testing:**
- Dashboard loads without errors
- No terminal button visible
- Ctrl+` shortcut removed

  - [x] Explore > Research: investigate codebase and problem space
  - [x] Explore > Share: inform user of findings before continuing
  - [x] Design > Draft: create initial design/approach
  - [x] Design > Review: show user, iterate if needed
  - [x] Prototype > Build: create the prototype
  - [x] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [x] Feedback > Demo: show user the prototype
  - [x] Feedback > Iterate: make changes based on feedback
  - [x] Implement > Build: implement real logic
  - [x] Implement > Verify: test functionality works
  - [x] Polish > Build: add error handling, edge cases
  - [x] Polish > Verify: confirm edge cases handled
  - [x] Document > Write: update relevant documentation
  - [x] Document > Review: confirm docs match implementation
  - [x] Commit > Stage: review changes, stage files
  - [x] Commit > Commit: write message with assumptions noted

---

## Backend

> SvelteKit server - APIs, database, services.

### Session API

Tracks current work context.

**Status**: Complete
- [x] **BE.1 Session Endpoints**
  - [x] `GET /api/session` - Current session
  - [x] `GET /api/status` - Human-friendly status
  - [x] `POST /api/session/start` - Begin task
  - [x] `POST /api/session/complete` - Mark task done
  - [x] `POST /api/session/check` - Validate if on-plan

### Spec API

Manage the specification document.

**Status**: Complete
- [x] **BE.2 Spec Endpoints**
  - [x] `GET /api/spec/full` - Parsed spec structure
  - [x] `POST /api/spec/tick` - Toggle item status
  - [x] `POST /api/spec/add` - Add new feature (with workflow template)

### Repository API

Manage repo configuration.

**Status**: Complete
- [x] **BE.3 Repo Endpoints**
  - [x] `GET /api/repos` - List repos
  - [x] `POST /api/repos` - Add repo

### Bug Queue API

Track bugs for later.

**Status**: Complete
- [x] **BE.4 Bug Endpoints**
  - [x] `GET /api/bugs` - List bugs
  - [x] `POST /api/bugs` - Add bug

### Core Services

#### Spec Parser
Parses SPEC.md into structured data.

**Status**: Complete
- [x] **BE.5 Spec Parser** - `src/lib/server/spec/parser.ts`
  - [x] Area/item extraction
  - [x] User story capture
  - [x] Progress calculation
  - [x] Format validation

#### Spec Writer
Modifies SPEC.md programmatically.

**Status**: Complete
- [x] **BE.6 Spec Writer** - `src/lib/server/spec/writer.ts`
  - [x] Mark items complete/incomplete
  - [x] Add new items
  - [x] Add workflow template sub-items
  - [x] Update status emojis (with unicode fix)

### Database

SQLite via better-sqlite3.

**Status**: Complete
- [x] **BE.7 Database Layer** - `src/lib/server/db/`
  - [x] Schema (repos, sessions, bugs)
  - [x] Query functions

### CLI

Command-line interface with workflow documentation.

**Status**: Complete
- [x] **BE.8 CLI** - `src/cli/index.ts`
  - [x] status, start, tick, done commands
  - [x] check, add, bug commands
  - [x] workflow command (shows diagram)
  - [x] help command
- [x] **BE.9 Session & Task Management Improvements** - Simple session control and task editing.

> As a user, I want better control over sessions and ability to edit task details.
  - [x] Explore: understand problem, search existing functions
  - [x] Design: flow diagram if needed
  - [x] Prototype: backend with test data + frontend calling it
  - [x] `chkd idle` command - manually return session to idle
  - [x] Editable task title/description in detail popout
  - [x] Timer per task (track time on each)
  - [x] Fix main timer not resetting for each story
  - [x] Feedback: user reviews prototype
  - [x] Implement: connect real logic
  - [x] Polish: edge cases
- [x] [P1] **BE.10 Sync/Distribution System** - Auto-sync chkd skills, CLAUDE.md sections, and config to other projects using chkd

> As a developer, I want chkd updates to automatically roll out to all my projects so that every Claude instance has the latest workflow instructions and skills.
  - [x] Explore: what files need syncing (.claude/skills/*, CLAUDE.md, etc.)
  - [x] Design: manifest file listing syncable assets + versioning
  - [x] `chkd init` - Initialize chkd in a new project (copies skills, creates CLAUDE.md section)
  - [x] `chkd sync` - Pull latest from chkd source to current project
  - [x] `chkd sync --all` - Sync to all registered repos
  - [x] Version tracking in each project (.chkd-version or similar)
  - [x] Handle merge conflicts (project customizations vs chkd updates)
  - [ ] Optional: auto-sync on `npm update chkd` or git hook
- [x] **BE.10 Add version tracking to the CLI app - automatic updating - dont need to remeber** - The version tracking feature will allow users to view the version history of the CLI app, including details on what changes were made in each update.

> As a developer, I want to add version tracking to the CLI app so that I can easily see the history of changes made to the application.
  - [x] Explore: understand problem, search existing functions
  - [x] Implement: replace test data with real logic
  - [x] Polish: iterate based on usage
- [x] **BE.11 Add working pusle check message to bacd end** - Allow the AI to call a pulse with the state that it's still in just as a nice signal to the back end that we're still on track if there's a mismatch on the state of the platform and the the AI sending we can give it a little message and help get back on track

> As a developer, I want a health check endpoint so that I can monitor if the backend service is running properly.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [x] Polish: error states, edge cases, performance
  - [x] update documention & guides
- [x] **BE.12 Update Bug Workflow** - âŽ¿ Â   chkd bug "description" [--severity high|medium|low|critical]             
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            
                                                                                
       Quick-create a bug with minimal friction.                                
                                                                                
       OPTIONS:                                                                 
         --severity <level>   Set severity (default: medium)                    
                              Levels: critical, high, medium, low               
                                                                                
       WHEN TO USE:                                                             
         - You notice something broken while working                            
         - User reports an issue                                                
         - Test fails unexpectedly                                              
         - You want to track something for later                                
                                                                                
       EXAMPLES:                                                                
         chkd bug "Save button broken"                                          
         chkd bug "Login fails on mobile" --severity high                       
         chkd bug "Typo in footer" --severity low                               
         chkd bug "App crashes on startup" --severity critical                  
                                                                                
       NEXT STEPS:                                                              
         - Run 'chkd bugs' to see all bugs                                      
         - Use '/bugfix' in Claude Code to fix a bug systematically             
                                                                                
       TIP: Keep descriptions short but specific.        We need to update starting a bug making it more simple this should be add,

> Currently getting confused creating a bug rather then working on the bug simplgy
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
  - [ ] update documention and guides
- [x] **BE.13 Backend: Tags support in parser and writer** #backend #parser #writer - As a developer, I want tags to be parsed from spec markdown and written back correctly
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.14 MCP server HTTP refactor - fix UI sync issue** - Refactor MCP server to call SvelteKit API instead of direct DB access. Fixes UI not updating when MCP tools are called. See docs/PLAN-mcp-http-refactor.md for full plan.
  - [x] Create server-http.ts with HTTP client architecture
  - [ ] Update all MCP tools to use async API calls
  - [ ] Test all MCP tools work through API
  - [x] Update package.json to use new server
  - [ ] Verify UI updates within 2s of MCP calls
  - [ ] Remove old server.ts after verification
- [x] **BE.15 add spec repair and upgrade fucntions to MCP server** - > As a developer, I want MCP server functions to repair and upgrade specs so that I can maintain and improve existing specifications programmatically.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
  - [ ] overall all user documentation and guides - be thougher
- [x] **BE.16 send item to diffent repo - if user enters in wrong place. Transfur** - Allow users to move items that were created in the wrong repository to the correct one.

> As a user, I want to transfer items between repositories so that I can correct mistakes when I create content in the wrong place.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.17 add prompts used in LLM in settings for customer personalision.** - Allow customers to personalize the LLM prompts used in the system through a settings interface.

> As a user, I want to customize LLM prompts in settings so that I can personalize the AI responses to match my preferences.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **BE.18 upgrade the stoy create by including projct context** - Enhance the story creation process to include relevant project context information, making stories more informed and contextually aware.

> As a developer, I want story creation to include project context so that generated stories are more relevant and actionable.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **BE.19 Add testing into the workflow research  https://github.com/kenryu42/claude-code-safety-net** - starting point for reseaching how  https://github.com/kenryu42/claude-code-safety-net


> As a developer, I want integrated testing in the workflow so that I can catch bugs early and maintain code quality.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.20 Workflow Step Sub-Items** - Make `chkd add` generate nested checkboxes with required fields

> When user adds a feature, SPEC.md output changes from flat tasks to nested tasks with children, and includes required metadata.

**What we're building:**
```markdown
# BEFORE (current - flat, minimal metadata)
- [ ] **SD.5 My Feature** - Description
  - [ ] Explore: research problem
  - [ ] Design: plan approach

# AFTER (nested checkboxes, required fields)
- [ ] **SD.5 My Feature** - Description

> User story goes here

**Key requirements:**
- Validation feedback when missing fields
- Backwards compatible with existing specs
- Safe structure building

**Files to change:**
- file1.ts, file2.ts

**Testing:**
- Test case 1
- Test case 2

  - [ ] Explore: research problem
    - [ ] Research: investigate codebase
    - [ ] Share: inform user before continuing
  - [ ] Design: plan approach
    - [ ] Draft: create initial design
    - [ ] Review: show user, iterate
```

**Required fields when creating a feature:**
- Title (required)
- Description (required)
- User story (required)
- Key requirements (required) - safety, validation, backwards compat considerations
- Files to change (required) - which files will be modified
- Testing (required) - how to verify it works
- Area (required) - SD, FE, BE, FUT

**Implementation requirements:**
- Phases are fixed (Explore, Design, Prototype, Feedback, Implement, Polish, Document, Commit)
- Sub-tasks are fixed per phase (Research/Share, Draft/Review, Build/Verify, etc.)
- Phase description can be custom or default
- Validate: give agent feedback if submitting with missing required fields
- Backwards compat: API accepts string[] (flat) or structured format

**Files to change:**
- `src/lib/types.ts` - add WorkflowPhase type, FeatureSpec type
- `src/lib/server/spec/writer.ts` - update DEFAULT_WORKFLOW_STEPS + buildItemLines()
- `src/lib/components/FeatureCapture.svelte` - update DEFAULT_TASKS, add required field validation
- `src/routes/api/spec/add/+server.ts` - validate required fields, return helpful errors

**Testing:**
- `chkd add` without required fields â†’ helpful error message
- `chkd add "Test Feature" --area BE` with all fields â†’ SPEC.md has full structure
- UI wizard enforces required fields before proceeding
- Existing flat specs still parse correctly

  - [x] Explore: understand current feature creation flow
    - [x] Research: read FeatureCapture.svelte wizard, API endpoint, writer.ts
    - [x] Share: confirm current fields and where validation happens
  - [x] Design: define required fields and validation
    - [x] Draft: FeatureSpec type with all required fields, validation error messages
    - [x] Review: confirm fields list and error messages are helpful
  - [x] Implement: update writer.ts for new output format
    - [x] Build: buildItemLines() outputs key requirements, files, testing sections
    - [x] Verify: markdown output matches "AFTER" example above
  - [x] Implement: update FeatureCapture.svelte with required fields
    - [x] Build: add key requirements, files, testing, fileLink inputs; pass metadata to API
    - [x] Verify: fields display in review step and summary; defaults to TBC if empty
  - [x] Implement: update API validation
    - [x] Build: /api/spec/add validates required fields, returns helpful hints
    - [x] Verify: missing fields return clear error messages (already comprehensive)
  - [x] Implement: update CLI to show task context
    - [x] Build: `chkd start` shows story, requirements, files, testing
    - [x] Build: `chkd progress` shows task context above sub-items
    - [x] Build: `chkd working` shows task context when starting sub-item
    - [x] Verify: context displays correctly (already implemented)
  - [x] Implement: add phase hints for Document and Commit
    - [x] Build: Document hint - already in working() function
    - [x] Build: Commit hint - already in working() function
    - [x] Verify: hints show when working on Document/Commit phases
  - [x] Polish: end-to-end testing
    - [x] Build: test CLI and UI paths, test backwards compat
    - [x] Verify: all paths work, existing specs unaffected
  - [x] Document: update templates
    - [x] Write: update SPEC.md.template with new structure
    - [x] Review: templates match implementation
- [ ] **BE.21 Story type flags for different workflows** - As a developer, I want to specify story types (remove, backend, refactor) when adding items so the workflow phases match the task

**Key requirements:**
- Add --type flag to chkd add command
- Support types: remove, backend, refactor
- Each type generates different workflow phases
- Update writer.ts to handle type-specific phases

**Files to change:**
- src/cli/index.ts
- src/lib/server/spec/writer.ts
- src/routes/api/spec/add/+server.ts

**Testing:**
- chkd add "test" --type remove creates item with reduced phases
- chkd add "test" --type backend skips UI phases
- Default (no type) still creates full workflow

  - [~] Explore > Research: investigate codebase and problem space
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Build: add error handling, edge cases
  - [ ] Polish > Verify: confirm edge cases handled
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: write message with assumptions noted

---

## Multi-Worker System

> Parallel Claude workers using git worktrees. Master Claude coordinates, workers execute.

### Phase 1: Foundation ðŸš§
- [x] **MW.1 Workers Database Schema** - Tables for workers, history, and signals
  - [x] Create workers table (id, task_id, status, worktree_path, branch_name, heartbeat)
  - [x] Create worker_history table (audit trail for completed workers)
  - [x] Create manager_signals table (coordinator messages to user)
  - [x] Add worker_id and is_master to sessions table
  - [x] Add TypeScript types (Worker, WorkerHistory, ManagerSignal, API types)

- [x] **MW.2 Git Worktree Utilities** - Create, remove, and manage worktrees
  - [x] createWorktree(repoPath, worktreePath, branchName) - Creates worktree + feature branch
  - [x] removeWorktree(repoPath, worktreePath, deleteBranch?) - Cleans up worktree
  - [x] listWorktrees(repoPath) - List all worktrees for a repo
  - [x] checkConflicts(repoPath, branchName, targetBranch?) - Pre-merge conflict detection
  - [x] mergeBranch(repoPath, branchName, targetBranch?, commitMessage?) - Merge with conflict check
  - [x] getBranchStats(repoPath, branchName, targetBranch?) - Get diff statistics
  - [x] Helper functions: generateWorkerId, generateBranchName, generateWorktreePath, getUsername

- [x] **MW.3 Worker API Endpoints** - CRUD for workers
  - [x] POST /api/workers - Spawn worker (creates worktree, branch, DB record)
  - [x] GET /api/workers?repoPath=... - List active workers
  - [x] GET /api/workers/:id - Get worker details
  - [x] PATCH /api/workers/:id - Update status/heartbeat/progress
  - [x] DELETE /api/workers/:id - Stop worker, cleanup worktree
  - [x] POST /api/workers/:id/complete - Complete task + auto-merge
  - [x] Database queries: getWorkers, createWorker, updateWorker, etc.
  - [x] Manager signals: create on spawn, status changes, merge results

### Phase 2: One-Click Spawning ðŸš§
- [x] **MW.4 Worker MCP Tools** - Master Claude spawns and manages workers
  - [x] chkd_spawn_worker(taskId, taskTitle, nextTaskId?, nextTaskTitle?)
  - [x] chkd_workers() - List active workers with status
  - [x] chkd_pause_worker(workerId) / chkd_resume_worker(workerId)
  - [x] chkd_merge_worker(workerId, autoMerge?, commitMessage?)
  - [x] chkd_stop_worker(workerId, force?, deleteBranch?)
  - [x] HTTP client functions for all worker API calls

- [x] **MW.5 Worker Heartbeat System** - Workers report status
  - [x] chkd_worker_heartbeat(workerId, message?, progress?) - Worker reports status
  - [x] chkd_worker_complete(workerId, summary?) - Worker signals done + auto-merge
  - [x] chkd_worker_status(workerId) - Worker checks own status/instructions
  - [x] chkd_dead_workers(thresholdMinutes?) - Master checks for stuck workers
  - [x] GET /api/workers/dead - Dead worker detection endpoint

- [x] **MW.6 Enhanced Repo Card UI** - Show workers at high level
  - [x] Taller repo card with worker summary strip
  - [x] Worker status indicators (ðŸŸ¢ working, ðŸŸ¡ merging, âš ï¸ conflict)
  - [x] Manager signal preview in card
  - [x] "Spawn Worker" button

### Phase 3: Split Brain View & Auto-Merge
- [x] **MW.7 Split Brain View** - Side-by-side worker panels
  - [x] Current task + progress per worker
  - [x] Next in queue display
  - [ ] Recently touched files list (needs git integration)
  - [x] Pause/Stop/View Code actions

- [x] **MW.8 Manager Signal Bar** - Coordinator communication
  - [x] Status updates ("Both workers on track...")
  - [x] Decision notifications ("âœ… Merged SD.3!")
  - [x] Help requests ("âš ï¸ Conflict in App.svelte")
  - [x] Suggestions ("ðŸ’¡ Spawn W2 for SD.4?")

- [x] **MW.9 Auto-Merge System** - Merge when safe, ask when not
  - [x] Pre-merge conflict check
  - [x] Auto-merge if clean
  - [x] Conflict resolution UI (keep mine/theirs/both)
  - [x] Worktree cleanup after merge

### Phase 4: Manager as Tech Lead âœ…
- [x] **MW.10 Manager Research Mode** - Explore codebase before assigning work
  - [x] Codebase exploration tools for Manager
  - [x] Pattern detection (find existing auth, DB patterns, etc.)
  - [x] Dependency analysis (what does this touch?)
  - [x] Research summary for user approval

- [x] **MW.11 Manager Story Writer** - Create detailed specs from user requests
  - [x] Parse user request into structured story
  - [x] Generate acceptance criteria
  - [x] Break into worker-assignable sub-tasks
  - [x] Estimate complexity/dependencies
  - [x] Present story for user approval before spawning

- [x] **MW.12 Manager Code Review** - Review worker output before merge
  - [x] Pull and diff worker branch
  - [x] Check code quality (patterns, style, tests)
  - [x] Verify acceptance criteria met
  - [x] Send feedback to worker if issues
  - [x] Approve for merge when satisfied

- [x] **MW.13 Manager Documenter** - Update docs after work completes
  - [x] Update README with new features
  - [x] Add entry to CHANGELOG
  - [x] Update API docs if endpoints changed
  - [x] Update inline code comments if needed
  - [x] Commit docs update with merge

### Phase 5: External Collaboration âœ…
- [x] **MW.14 External Story Submission** - Allow non-developers to submit feature ideas
  - [x] Public-facing form to submit story/feature idea
  - [x] Story lands in "Ideas" queue (not spec yet)
  - [x] Manager reviews and refines submissions
  - [x] Approve to promote to spec, or reject with feedback
  - [x] Email notification when idea is accepted/rejected
  - [x] Simple auth (email link or code) for submitters to track their ideas

> As a stakeholder/user, I want to submit feature ideas without needing to edit the spec directly, so that I can contribute ideas even if I'm not a developer.

### Future: SaaS Platform
- [x] **MW.15 SaaS Architecture** - Design for hosted multi-tenant platform
  - [x] PostgreSQL migration path from SQLite
  - [x] Multi-tenant data isolation
  - [x] Team workspaces with roles (admin, dev, viewer)
  - [x] GitHub/GitLab app integration
  - [x] Managed Claude workers (cloud-hosted)
  - [x] Usage-based billing infrastructure
  - [x] Analytics dashboard (velocity, time tracking)

> As a team, we want a hosted chkd service so we don't need to run infrastructure ourselves.

---

## Future Areas

> Not yet started. Organized by what they'll touch.

### Quality Features (v3+)
- [ ] **FUT.1 Test Generation** - Auto-generate tests on commit (port from v1)
- [ ] **FUT.2 Sceptic Check** - Validate ideas before building
- [ ] **FUT.3 Quality Gates** - Block bad code from main
- [ ] **FUT.4 Code Health Checks** - Simple quality checks before/after tasks using jscpd (duplication) and knip (dead code). Integrate into Explore phase - flag issues, let user decide to refactor or proceed. Not a gate, just information.

> As a developer, I want code health checks before starting a task so I can decide whether to refactor first, and after finishing so I can log any new technical debt.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance

### Git & Source Control (UI owns this)
- [ ] **FUT.4 Diff View** - See what changed during session
- [ ] **FUT.5 Staging UI** - Select files to commit
- [ ] **FUT.6 Commit Flow** - Pre-fill message from session, commit
- [ ] **FUT.7 Push to Remote** - Push when ready
- [ ] **FUT.8 Audit Trail** - History of commits per session

### Advanced Features
- [ ] **FUT.9 WebSocket Updates** - Real-time UI updates
- [ ] **FUT.10 Version History** - Track spec changes over time
- [ ] **FUT.11 Create the best debug workflow and tool in the MCP ever created** - Create comprehensive debugging capabilities and workflow tools that surpass existing MCP debugging solutions.

> As a developer, I want powerful debug tools and workflows so that I can efficiently troubleshoot and resolve issues in the MCP system.
  - [ ] Explore: research existing MCP debug tools & pain points
  - [ ] Explore: audit current logging/error handling capabilities
  - [ ] Design: debug workflow + tool architecture/contracts
  - [ ] Prototype: core debug tools with mock error scenarios
  - [ ] Get feedback: test debug workflow with real issues
  - [ ] Implement: full debug toolset with enhanced logging
  - [ ] Polish: refine tools based on usage patterns
  - [ ] Document: debug workflow guide & tool reference

---

## Reference

### Workflow Template

Every feature added gets these 8 steps:
```
- [ ] Explore: research problem, check existing code/patterns
- [ ] Design: plan approach + define endpoint contracts
- [ ] Prototype: build UI with mock data, stub backend
- [ ] Feedback: user reviews and approves UX
- [ ] Implement: connect real backend logic
- [ ] Polish: error states, edge cases, performance
- [ ] Document: update docs, guides, and CLAUDE.md if needed
- [ ] Commit: commit code to git with clear message + assumptions
```

### Spec Format Rules

- Area header: `## Area Name` or `### Sub-Area`
- Section numbers: `**XX.N Feature Name**` (e.g., BE.1, FE.2)
- Checklist: `- [ ]` or `- [x]`
- User story: Blockquote `>`
- Status line: `**Status**: Complete/In Progress/Not started`

### Design Standards

- Colors: CSS variables (`--primary`, `--success`, etc.)
- Border radius: 6px inputs, 8px buttons, 12px cards
- Spacing: 4px base (4, 8, 12, 16, 24, 32)
- Status emoji: âœ… complete, ðŸš§ in-progress, ðŸ“‹ pending

### Code Standards

- Files: `kebab-case.ts`
- Classes: `PascalCase`
- Functions: `camelCase`
- API responses: `{ success, data?, error? }`

---

## Skills

Available Claude Code skills:

| Skill | Purpose |
|-------|---------|
| `/chkd` | Build mode - check session, implement tasks with polish |
| `/bugfix` | Fix bugs without feature creep - research first |
| `/story` | Develop stories - assess, question, refine specs |
| `/spec-check` | Validate SPEC.md format after editing |
