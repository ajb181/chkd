# chkd v2 Specification

> Organized by **system area** rather than build phase.
> The spec is both the todo list and the map of what exists.

<!-- âš ï¸ CLAUDE: Do NOT edit this file directly! Use chkd CLI commands:
     - chkd add "feature" - Add new items
     - chkd tick "item"   - Mark items complete
     - chkd working "item" - Mark items in-progress
     This keeps the UI in sync and tracks changes properly. -->

---

## Overview

**chkd** is a development workflow system that makes AI-assisted development structured and consistent.

**Core idea**: Plan in one place (UI), build in another (terminal). The spec is the source of truth.

---

## Site Design

> How chkd looks and feels. Pages, layouts, user flows.

### Pages

#### Guide (`/guide`)
How to use chkd - workflow explanation, commands, troubleshooting.

**Status**: Docs exist, UI page needed
- [x] **SD.1 Guide Documentation** - docs/GUIDE.md created
- [x] **SD.2 Guide Page** - Svelte page at /guide route

#### Command Center (`/`)
The main workspace. Shows current task, story list, progress.

**Status**: Not started
- [x] **SD.3 Command Center Layout** - Main page structure

#### Settings (`/settings`)
Configure repos and preferences.

**Status**: Not started
- [x] **SD.4 Settings Page** - Basic settings

### Design System

- [x] **SD.5 CSS Variables** - Color system, spacing, typography
- [x] **SD.6 Component Styles** - Buttons, cards, inputs
- [x] **SD.7 Dark Mode** - Full dark theme support
- [x] **SD.8 Queue List for Off-Task Items** - Capture todos during active session, surface on tick with instructions for Claude to add to internal todo
- [x] **SD.11 Can we add a task to replace the drop-down menu for swapping the repose I'm imagining a set of cards that run across the top they have a bit of information about the repo and what's developing where it's at like a very condensed high-level and you can click between them really easily and they're showing you what each one's working on at the moment or if it's idle** - The cards will run across the top of the screen, displaying details like the repository name, what's currently being developed, and the overall status.

> As a product manager, I want a set of cards that show high-level information about each repository so that I can easily see what's being worked on and the status of each area. You can click them to nav between them
- [x] **SD.12 Embedded Terminal** - Add xterm.js terminal to chkd UI with tmux backend for session persistence. Can run Claude Code directly in the web app, survives page refresh, can also attach from regular terminal.
  - [!] Future: Connect blocking questions API to terminal events
  - [!] Fix terminal overflow/cropping issue (tmux status bar leaks outside container)
- [x] **SD.13 add instrcutions into the Philosophy to use for bug fix when getting bugs, add apply to size the bug big or small using different approaches** - The feature will allow developers to include instructions in the Philosophy section of the application to provide guidance on how to approach and fix bugs, as well as provide tools to help assess the size and complexity of the bug.

> As a developer, I want to be able to add instructions into the Philosophy section to help with bug fixes, and be able to apply different approaches to size the bug as small or large, so that I can more effectively resolve issues.
  - [x] Explore: understand problem, search existing functions
  - [ ] Design: flow diagram if needed
  - [x] Prototype: backend with test data + frontend calling it
  - [x] Feedback: user reviews prototype
  - [ ] Implement: replace test data with real logic
  - [ ] Polish: iterate based on usage
- [x] **SD.14 Can we add a list somewhere of quick wins I think maybe on the card you can click in it just opens similar to bugs and you can just bang it in there and you can tell the AI just took it through the quick wins** - The quick wins list should be accessible from the card view, allowing users to easily log and view items that can be quickly addressed.

> As a user, I want a quick wins list that I can easily access and add to, so that I can quickly capture and surface potential improvements.
- [x] **Track and display time spent on each checklist item - store duration when ticked, show in UI**
  - [x] Explore: check existing checklist data structure + timing patterns
  - [x] Design: duration storage schema + UI display mockups
  - [x] Prototype: timer UI + mock duration data display
  - [ ] Feedback: user tests timing UX and display format
  - [ ] Implement: real duration tracking + database storage
  - [ ] Polish: pause/resume states + duration formatting
- [x] **FE Terminal WebSocket connection - investigate why terminal shows disconnected and fix**
- [x] **SD.16 allow a file to be added into a bug or sotry** - Enable users to attach files (documents, images, logs, etc.) to bug reports and stories for better context and documentation.

> As a developer, I want to attach files to bugs and stories so that I can provide additional context like screenshots, logs, or documentation.
- [x] **SD.17 add impromptu and debug work states so the UI is always engaged regardless** - At the moment it can be idle in the app but actually the code is working so we're looking to solve those solutions both when in debug and impromptu work

> As a developer, I want impromptu and debug work states so that the UI stays engaged during all types of work sessions.
- [x] **SD.18 allow file to be attached when creating bug or story** - Enable users to attach files (documents, images, logs, etc.) to bug reports and user stories for better context and documentation.

> As a developer, I want to attach files to bugs and stories so that I can provide additional context like screenshots, logs, or documentation.
- [x] **SD.19 Update the brand homepage** - > As a website visitor, I want to see an updated brand homepage so that I get the latest information about the company and its offerings.
- [x] **SD.20 add most recent adds to the spec & most recent acchieved** - Display the most recently added items and recently completed/achieved features prominently in the specification interface.

> As a developer, I want to see recent additions and achievements in the spec so that I can quickly track progress and stay updated on latest changes.
- [ ] **SD.21 AI Prompt Studio - View, edit, version, and test all LLM prompts** - As a user, I want to see and edit all AI prompts used in chkd so that I can customize how the AI generates content and have full transparency and control. Based on Strateo's proven AI Studio architecture with version control, testing, and audit trails.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **SD.22 World-Class User Guide - Searchable, production-ready documentation for all user levels** - Complete overhaul of the chkd guide to be world-class, searchable, and production-ready for public launch.
  - [x] Research: Best practices for developer documentation and user guides
  - [x] Research: Review all spec docs, research docs, and codebase - build product knowledge doc
  - [x] Design: Guide structure and information architecture
  - [ ] Implement: Searchable documentation system
  - [ ] Write: New user journey (install, first run, quick start)
  - [ ] Write: Active user guide (daily workflows, features, customization)
  - [ ] Write: Power user guide (multi-worker, MCP tools, advanced features)
  - [ ] Write: Team/SaaS setup guide (team management, enterprise features)
  - [ ] Polish: Troubleshooting, FAQ, and edge cases
  - [ ] Review: Final quality check and user testing

**User Journey Coverage:**
- ðŸ†• New User: Installation, first run, core concepts, quick start
- ðŸ‘¤ Active User: Daily workflows, features, customization, settings
- âš¡ Power User: Multi-worker system, MCP tools, advanced features
- ðŸ‘¥ Team Lead: SaaS setup, team management, enterprise features

**Key Requirements:**
1. Research best practices for developer documentation and user guides
2. Review all spec docs, research docs, and codebase for complete product understanding
3. Searchable documentation (consider Algolia, local search, or built-in)
4. Production-ready for someone to pickup, install, and run
5. Include SaaS setup as complete (verify at launch)
6. Consider user evolution from beginner to expert

**Deliverables:**
- Comprehensive GUIDE.md or guide system
- Quick start guide (5-minute setup)
- Feature reference by user level
- Troubleshooting section
- SaaS/Team setup guide
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **SD.23 Multi-Worker System Integration Testing** - As a developer, I want to validate the multi-worker system works end-to-end so that we can confidently use parallel workers for feature development.

**Acceptance Criteria:**
- [ ] Can spawn a worker from the dashboard
- [ ] Worker Claude can claim the task
- [x] Worker sends heartbeats visible in UI
- [ ] Worker completes and auto-merges (clean case)
- [ ] Conflict resolution works when workers touch same files
- [ ] Dead worker detection fires when worker stops sending heartbeats
- [ ] Manager signals appear in UI for all events
- [ ] Two workers can run in parallel without issues
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **SD.24 Mobile Capture repo setup** #mobile-capture-app - Create mobile-capture-app repo with Expo template, same stack as budget_project (expo-router, TypeScript, React 19)

**Key requirements:**
- Create new repo `mobile-capture-app` with Expo template
- Match budget_project stack: expo-router, TypeScript, React 19
- Basic folder structure for future feature expansion
- Git initialized with initial commit

**Files to change:**
- New repo: mobile-capture-app/
- package.json with Expo dependencies
- tsconfig.json for TypeScript
- app/ directory for expo-router

**Testing:**
- `npx expo start` runs without errors
- Basic navigation between screens works
- TypeScript compilation passes

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [~] **SD.25 Review service project setup** #stateless-review-service - Create review service in chkd with Playwright dependency and API endpoint

**Key requirements:**
- Stateless design: spawn, process, return, exit (no persistent state)
- Playwright with Chromium for headless screenshots
- API endpoint at POST /api/review-build
- Support wireframe as image (.png/.jpg) OR HTML file
- Types for ReviewRequest and ReviewResult

**Files to change:**
- src/lib/server/review/types.ts - Request/Result interfaces
- src/lib/server/review/index.ts - Main review function (stub for BE.27/BE.28)
- src/routes/api/review-build/+server.ts - HTTP endpoint
- package.json - Playwright dependency

**Testing:**
- `curl -X POST /api/review-build` with url+scope returns proper error (not implemented yet)
- Validation: missing url/scope returns 400 with clear error message
- Playwright installed: `npx playwright --version` works

  - [x] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [x] Explore > Questions: consider if clarification needed - ask user if unclear
  - [x] Explore > Share: inform user of findings before continuing
  - [x] Design > Draft: create initial design/approach
  - [x] Design > Review: show user, iterate if needed
  - [x] Prototype > Build: create the prototype
  - [x] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [x] Feedback > Demo: show user the prototype
  - [x] Feedback > Iterate: make changes based on feedback
  - [x] Implement > Build: implement real logic
  - [x] Implement > Verify: test functionality works
  - [x] Polish > Consider: wider impact - loading states, empty states, error displays
  - [x] Polish > Review: open browser, visually check UI renders correctly
  - [x] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [x] Document > Write: update relevant documentation
  - [x] Document > Review: confirm docs match implementation
  - [x] Commit > Stage: review changes, stage files
  - [x] Commit > Commit: summary line (what), body (why + assumptions), push to remote
---

## Frontend

> Svelte components, stores, client-side logic.

### Core Components

#### CurrentTaskCard
Shows active task status, progress, actions.

**Status**: Not started

#### StoryList
Collapsible list of areas and stories.

**Status**: Complete
- [x] **FE.2 StoryList Component**

#### StoryDetail
Full story view with checklist.

**Status**: Complete
- [x] **FE.3 StoryDetail Component**

#### FeatureCapture
Add new features to the spec.

**Status**: Not started
- [x] **FE.4 FeatureCapture Component**

### State Management

- [x] **FE.5 Stores** - Svelte stores for app state

### Client API

- [x] **FE.6 API Client** - Functions to call backend
- [x] **FE.7 Allow to set tags and priority when creating a story and it's tasks** - This feature will allow users to add tags and set priority levels for stories and tasks, enabling more efficient task management and organization.

> As a user, I want to be able to set tags and priority when creating a story and its tasks so that I can better organize and prioritize my work.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
    - [ ] Add tags property to SpecItem interface
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [!] **FE.8 Redesign how the terminal fits into the app UI I think it should be 50-50 columns with the work list to fill that column currently at sort of floating or something** - Currently the terminal appears to be floating. Should be restructured as a proper column layout sharing space equally with the work list. BLOCKED: tmux status bar overflow/cropping not fully resolved, need different approach.

> As a developer, I want the terminal and work list in a 50-50 column layout so that I can efficiently view both simultaneously without overlapping UI elements.
  - [x] Explore: research problem, check existing code/patterns
  - [x] Design: plan approach + define endpoint contracts
  - [x] Prototype: build UI with mock data, stub backend
  - [x] Feedback: user reviews and approves UX
  - [x] Implement: connect real backend logic
  - [!] Polish: overflow/cropping issue with tmux status bar needs different approach
- [x] **FE.9 Remove terminal from UI** - Delete embedded terminal code and button from dashboard

> As a developer, I want to remove the unused terminal feature so the codebase is cleaner

**Key requirements:**
- Remove terminal button from nav
- Remove terminal panel from main area
- Remove terminal state and imports
- Remove terminal CSS styles

**Files to change:**
- src/routes/+page.svelte

**Testing:**
- Dashboard loads without errors
- No terminal button visible
- Ctrl+` shortcut removed

- [ ] **FE.10 Epic view in UI - filter items by epic tag** - Add toggle in dashboard to switch between area view (current) and epic view. Epic view groups all items with same epic tag together, showing progress across areas. Makes it easy to see "everything for Auth System" instead of hunting through SD/FE/BE sections.

**Key requirements:**
- Toggle button in dashboard header to switch area/epic view
- Epic view groups items by their #epic-tag across all areas
- Show epic progress (X/Y complete) for each group
- Clicking epic name links to docs/epics/{name}.md

**Files to change:**
- src/routes/+page.svelte - Add view toggle, epic grouping logic
- src/lib/components/ - May need EpicGroup.svelte component
- src/lib/api.ts - May need endpoint for epic aggregation

**Testing:**
- Toggle switches between area and epic views
- Items with same epic tag appear grouped together
- Progress shows correctly across areas
- Empty state when no epics exist

  - [x] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [x] Explore > Questions: consider if clarification needed - ask user if unclear
  - [x] Explore > Share: inform user of findings before continuing
  - [x] Design > Draft: create initial design/approach
  - [x] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **FE.11 App shell & navigation** #mobile-capture-app - Expo setup with expo-router, basic screen structure (Chat, History, Settings)

**Key requirements:**
- expo-router file-based navigation
- Bottom tab bar with 3 tabs: Chat (default), History, Settings
- Consistent header styling across screens
- TypeScript throughout

**Files to change:**
- app/_layout.tsx - Root layout with tab navigation
- app/(tabs)/index.tsx - Chat screen (default)
- app/(tabs)/history.tsx - History screen
- app/(tabs)/settings.tsx - Settings screen

**Testing:**
- App launches to Chat tab
- Bottom tabs navigate between screens
- Back navigation works correctly
- No TypeScript errors

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **FE.12 Chat interface** #mobile-capture-app - Conversation UI - message bubbles, text input, send button, loading states. Connect to /api/capture/chat

**Key requirements:**
- Message bubbles (user right, AI left) with timestamps
- Text input with send button at bottom
- Loading indicator while AI responds
- Auto-scroll to latest message
- Keyboard handling (input moves above keyboard)

**Files to change:**
- app/(tabs)/index.tsx - Chat screen with message list
- components/MessageBubble.tsx - Individual message component
- components/ChatInput.tsx - Text input with send button
- hooks/useChat.ts - Chat state and API calls

**Testing:**
- Messages display correctly (user vs AI styling)
- Send button triggers API call
- Loading state shows during response
- Keyboard doesn't obscure input

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **FE.13 Object preview & confirm** #mobile-capture-app - Show structured object (story/epic) before pushing, let user edit title/description, confirm to push

**Key requirements:**
- Modal/sheet showing extracted object (type, title, description, area)
- Editable fields for title and description
- Area code selector (SD/FE/BE/FUT)
- Confirm and Cancel buttons
- Shows which chkd repo it will push to

**Files to change:**
- components/ObjectPreview.tsx - Preview modal component
- components/AreaPicker.tsx - Area code selector
- app/(tabs)/index.tsx - Trigger preview from chat

**Testing:**
- Preview shows correct extracted data
- Fields are editable
- Confirm triggers push to chkd
- Cancel returns to chat without pushing

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **FE.14 Settings screen** #mobile-capture-app - Configure chkd server URL (default localhost:3847), test connection button

**Key requirements:**
- Server URL input (default: http://localhost:3847)
- Test Connection button with success/failure feedback
- Persist settings to device storage
- Show current connection status

**Files to change:**
- app/(tabs)/settings.tsx - Settings screen UI
- lib/storage.ts - AsyncStorage wrapper for settings
- lib/api.ts - API client with configurable base URL

**Testing:**
- URL persists after app restart
- Test Connection shows success for valid server
- Test Connection shows error for invalid/offline server
- API calls use configured URL

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **FE.15 Capture history** #mobile-capture-app - List of recently captured ideas with push status, tap to view details

**Key requirements:**
- List of captured objects with title, type, timestamp
- Status indicator (pushed, pending, failed)
- Tap to view full details
- Pull-to-refresh to sync status
- Persist locally even when offline

**Files to change:**
- app/(tabs)/history.tsx - History list screen
- components/HistoryItem.tsx - Individual history row
- lib/storage.ts - Local history storage
- components/HistoryDetail.tsx - Detail view modal

**Testing:**
- New captures appear in history
- Status updates after push succeeds/fails
- Tap opens detail view
- History persists after app restart

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - loading states, empty states, error displays
  - [ ] Polish > Review: open browser, visually check UI renders correctly
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote

---

## Backend

> SvelteKit server - APIs, database, services.

### Session API

Tracks current work context.

**Status**: Complete
- [x] **BE.1 Session Endpoints**

### Spec API

Manage the specification document.

**Status**: Complete
- [x] **BE.2 Spec Endpoints**

### Repository API

Manage repo configuration.

**Status**: Complete
- [x] **BE.3 Repo Endpoints**

### Bug Queue API

Track bugs for later.

**Status**: Complete
- [x] **BE.4 Bug Endpoints**

### Core Services

#### Spec Parser
Parses SPEC.md into structured data.

**Status**: Complete
- [x] **BE.5 Spec Parser** - `src/lib/server/spec/parser.ts`

#### Spec Writer
Modifies SPEC.md programmatically.

**Status**: Complete
- [x] **BE.6 Spec Writer** - `src/lib/server/spec/writer.ts`

### Database

SQLite via better-sqlite3.

**Status**: Complete
- [x] **BE.7 Database Layer** - `src/lib/server/db/`

### CLI

Command-line interface with workflow documentation.

**Status**: Complete
- [x] **BE.8 CLI** - `src/cli/index.ts`
- [x] **BE.9 Session & Task Management Improvements** - Simple session control and task editing.

> As a user, I want better control over sessions and ability to edit task details.
- [x] [P1] **BE.10 Sync/Distribution System** - Auto-sync chkd skills, CLAUDE.md sections, and config to other projects using chkd

> As a developer, I want chkd updates to automatically roll out to all my projects so that every Claude instance has the latest workflow instructions and skills.
  - [x] Explore: what files need syncing (.claude/skills/*, CLAUDE.md, etc.)
  - [x] Design: manifest file listing syncable assets + versioning
  - [x] `chkd init` - Initialize chkd in a new project (copies skills, creates CLAUDE.md section)
  - [x] `chkd sync` - Pull latest from chkd source to current project
  - [x] `chkd sync --all` - Sync to all registered repos
  - [x] Version tracking in each project (.chkd-version or similar)
  - [x] Handle merge conflicts (project customizations vs chkd updates)
  - [ ] Optional: auto-sync on `npm update chkd` or git hook
- [x] **BE.10 Add version tracking to the CLI app - automatic updating - dont need to remeber** - The version tracking feature will allow users to view the version history of the CLI app, including details on what changes were made in each update.

> As a developer, I want to add version tracking to the CLI app so that I can easily see the history of changes made to the application.
- [x] **BE.11 Add working pusle check message to bacd end** - Allow the AI to call a pulse with the state that it's still in just as a nice signal to the back end that we're still on track if there's a mismatch on the state of the platform and the the AI sending we can give it a little message and help get back on track

> As a developer, I want a health check endpoint so that I can monitor if the backend service is running properly.
- [x] **BE.12 Update Bug Workflow** - âŽ¿ Â   chkd bug "description" [--severity high|medium|low|critical]             
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            
                                                                                
       Quick-create a bug with minimal friction.                                
                                                                                
       OPTIONS:                                                                 
         --severity <level>   Set severity (default: medium)                    
                              Levels: critical, high, medium, low               
                                                                                
       WHEN TO USE:                                                             
         - You notice something broken while working                            
         - User reports an issue                                                
         - Test fails unexpectedly                                              
         - You want to track something for later                                
                                                                                
       EXAMPLES:                                                                
         chkd bug "Save button broken"                                          
         chkd bug "Login fails on mobile" --severity high                       
         chkd bug "Typo in footer" --severity low                               
         chkd bug "App crashes on startup" --severity critical                  
                                                                                
       NEXT STEPS:                                                              
         - Run 'chkd bugs' to see all bugs                                      
         - Use '/bugfix' in Claude Code to fix a bug systematically             
                                                                                
       TIP: Keep descriptions short but specific.        We need to update starting a bug making it more simple this should be add,

> Currently getting confused creating a bug rather then working on the bug simplgy
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
  - [ ] update documention and guides
- [x] **BE.13 Backend: Tags support in parser and writer** #backend #parser #writer - As a developer, I want tags to be parsed from spec markdown and written back correctly
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.14 MCP server HTTP refactor - fix UI sync issue** - Refactor MCP server to call SvelteKit API instead of direct DB access. Fixes UI not updating when MCP tools are called. See docs/PLAN-mcp-http-refactor.md for full plan.
  - [x] Create server-http.ts with HTTP client architecture
  - [ ] Update all MCP tools to use async API calls
  - [ ] Test all MCP tools work through API
  - [x] Update package.json to use new server
  - [ ] Verify UI updates within 2s of MCP calls
  - [ ] Remove old server.ts after verification
- [x] **BE.15 add spec repair and upgrade fucntions to MCP server** - > As a developer, I want MCP server functions to repair and upgrade specs so that I can maintain and improve existing specifications programmatically.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
  - [ ] overall all user documentation and guides - be thougher
- [x] **BE.16 send item to diffent repo - if user enters in wrong place. Transfur** - Allow users to move items that were created in the wrong repository to the correct one.

> As a user, I want to transfer items between repositories so that I can correct mistakes when I create content in the wrong place.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.17 add prompts used in LLM in settings for customer personalision.** - Allow customers to personalize the LLM prompts used in the system through a settings interface.

> As a user, I want to customize LLM prompts in settings so that I can personalize the AI responses to match my preferences.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **BE.18 upgrade the stoy create by including projct context** - Enhance the story creation process to include relevant project context information, making stories more informed and contextually aware.

> As a developer, I want story creation to include project context so that generated stories are more relevant and actionable.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [ ] **BE.19 Add testing into the workflow research  https://github.com/kenryu42/claude-code-safety-net** - starting point for reseaching how  https://github.com/kenryu42/claude-code-safety-net


> As a developer, I want integrated testing in the workflow so that I can catch bugs early and maintain code quality.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance
- [x] **BE.20 Workflow Step Sub-Items** - Make `chkd add` generate nested checkboxes with required fields

> When user adds a feature, SPEC.md output changes from flat tasks to nested tasks with children, and includes required metadata.

**What we're building:**
```markdown
# BEFORE (current - flat, minimal metadata)
- [ ] **SD.5 My Feature** - Description
  - [ ] Explore: research problem
  - [ ] Design: plan approach

# AFTER (nested checkboxes, required fields)
- [ ] **SD.5 My Feature** - Description

> User story goes here

**Key requirements:**
- Validation feedback when missing fields
- Backwards compatible with existing specs
- Safe structure building

**Files to change:**
- file1.ts, file2.ts

**Testing:**
- Test case 1
- Test case 2

  - [ ] Explore: research problem
    - [ ] Research: investigate codebase
    - [ ] Share: inform user before continuing
  - [ ] Design: plan approach
    - [ ] Draft: create initial design
    - [ ] Review: show user, iterate
```

**Required fields when creating a feature:**
- Title (required)
- Description (required)
- User story (required)
- Key requirements (required) - safety, validation, backwards compat considerations
- Files to change (required) - which files will be modified
- Testing (required) - how to verify it works
- Area (required) - SD, FE, BE, FUT

**Implementation requirements:**
- Phases are fixed (Explore, Design, Prototype, Feedback, Implement, Polish, Document, Commit)
- Sub-tasks are fixed per phase (Research/Share, Draft/Review, Build/Verify, etc.)
- Phase description can be custom or default
- Validate: give agent feedback if submitting with missing required fields
- Backwards compat: API accepts string[] (flat) or structured format

**Files to change:**
- `src/lib/types.ts` - add WorkflowPhase type, FeatureSpec type
- `src/lib/server/spec/writer.ts` - update DEFAULT_WORKFLOW_STEPS + buildItemLines()
- `src/lib/components/FeatureCapture.svelte` - update DEFAULT_TASKS, add required field validation
- `src/routes/api/spec/add/+server.ts` - validate required fields, return helpful errors

**Testing:**
- `chkd add` without required fields â†’ helpful error message
- `chkd add "Test Feature" --area BE` with all fields â†’ SPEC.md has full structure
- UI wizard enforces required fields before proceeding
- Existing flat specs still parse correctly

  - [x] Explore: understand current feature creation flow
    - [x] Research: read FeatureCapture.svelte wizard, API endpoint, writer.ts
    - [x] Share: confirm current fields and where validation happens
  - [x] Design: define required fields and validation
    - [x] Draft: FeatureSpec type with all required fields, validation error messages
    - [x] Review: confirm fields list and error messages are helpful
  - [x] Implement: update writer.ts for new output format
    - [x] Build: buildItemLines() outputs key requirements, files, testing sections
    - [x] Verify: markdown output matches "AFTER" example above
  - [x] Implement: update FeatureCapture.svelte with required fields
    - [x] Build: add key requirements, files, testing, fileLink inputs; pass metadata to API
    - [x] Verify: fields display in review step and summary; defaults to TBC if empty
  - [x] Implement: update API validation
    - [x] Build: /api/spec/add validates required fields, returns helpful hints
    - [x] Verify: missing fields return clear error messages (already comprehensive)
  - [x] Implement: update CLI to show task context
    - [x] Build: `chkd start` shows story, requirements, files, testing
    - [x] Build: `chkd progress` shows task context above sub-items
    - [x] Build: `chkd working` shows task context when starting sub-item
    - [x] Verify: context displays correctly (already implemented)
  - [x] Implement: add phase hints for Document and Commit
    - [x] Build: Document hint - already in working() function
    - [x] Build: Commit hint - already in working() function
    - [x] Verify: hints show when working on Document/Commit phases
  - [x] Polish: end-to-end testing
    - [x] Build: test CLI and UI paths, test backwards compat
    - [x] Verify: all paths work, existing specs unaffected
  - [x] Document: update templates
    - [x] Write: update SPEC.md.template with new structure
    - [x] Review: templates match implementation
- [x] **BE.21 Story type flags for different workflows** - As a developer, I want to specify story types (remove, backend, refactor) when adding items so the workflow phases match the task

**Key requirements:**
- Add --type flag to chkd add command
- Support types: remove, backend, refactor
- Each type generates different workflow phases
- Update writer.ts to handle type-specific phases

**Files to change:**
- src/cli/index.ts
- src/lib/server/spec/writer.ts
- src/routes/api/spec/add/+server.ts

**Testing:**
- chkd add "test" --type remove creates item with reduced phases
- chkd add "test" --type backend skips UI phases
- Default (no type) still creates full workflow

- [ ] **BE.22 Mind Reader discovery mode** - Add --mind-reader flag to chkd add. Claude asks itself 30 product/UX/technical questions, answers based on context, writes to docs/mind-reader/{ID}-{title}.md. Helps create better specs upfront. Explore step references discovery docs, Polish > Confirm verifies against assumptions.

**Key requirements:**
- --mind-reader flag on chkd add MCP tool
- Generate 30 questions across product/UX/technical domains
- AI answers based on codebase context
- Output to docs/mind-reader/{ID}-{title}.md
- Link discovery doc in spec item

**Files to change:**
- src/mcp/server.ts - Add --mind-reader param to chkd_add
- src/lib/server/mindreader/ - New module for question generation
- docs/mind-reader/ - Output directory for discovery docs

**Testing:**
- chkd_add with mind-reader creates discovery doc
- Doc contains 30+ Q&A pairs
- Doc is linked in created spec item
- Explore phase can reference the doc

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: write message with assumptions noted
- [~] **BE.23 Epic management for large features** - Add epic system for big features that span multiple spec items. Epic lives in docs/epics/{name}.md with overview, tag, and scope. Items link via tag. UI can filter by epic to see all related items together. Includes overhaul checklist when all items complete - end-to-end test, integration check, final sign-off. Commands: chkd epic "name" (create), chkd add --epic (link item).

**Key requirements:**
- chkd_epic MCP tool creates docs/epics/{slug}.md
- Auto-generate tag from epic name (e.g., "Auth System" â†’ "auth-system")
- chkd_add accepts epic param to link items via #tag
- chkd_epics lists all epics with progress
- Epic doc includes overhaul checklist template

**Files to change:**
- src/mcp/server.ts - chkd_epic, chkd_epics, chkd_add epic param
- docs/epics/ - Epic documents directory
- src/lib/server/spec/parser.ts - Parse epic tags from items

**Testing:**
- chkd_epic creates doc with correct structure
- chkd_add --epic links item with tag
- chkd_epics shows progress across linked items
- Tag is auto-generated correctly from name

  - [x] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.24 Chat API endpoint** #mobile-capture-app - Add /api/capture/chat endpoint to chkd - conversation with AI, maintains context across messages

**Key requirements:**
- POST /api/capture/chat accepts {message, sessionId}
- Maintains conversation history per session
- Returns AI response with session context
- Session timeout after inactivity (configurable)
- System prompt guides toward idea extraction

**Files to change:**
- src/routes/api/capture/chat/+server.ts - Chat endpoint
- src/lib/server/capture/session.ts - Session management
- src/lib/server/capture/prompts.ts - System prompts for capture mode

**Testing:**
- New session creates conversation context
- Follow-up messages include history
- Session persists across multiple requests
- System prompt steers toward structured capture

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.25 Object extraction from chat** #mobile-capture-app - AI determines when idea is ready, extracts structured object (story/epic/bug/win) with title, description, area code

**Key requirements:**
- AI detects when idea is sufficiently refined
- Extracts: type (story/epic/bug/win), title, description, area code
- Returns structured JSON alongside conversational response
- Confidence score for extraction quality
- Allows user to continue refining if not ready

**Files to change:**
- src/lib/server/capture/extractor.ts - Object extraction logic
- src/lib/server/capture/prompts.ts - Extraction prompts
- src/routes/api/capture/chat/+server.ts - Include extraction in response

**Testing:**
- Clear ideas extract correctly
- Vague ideas prompt for clarification
- All object types supported (story, epic, bug, win)
- Area code inferred from context

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.26 Push to chkd integration** #mobile-capture-app - Connect extracted object to existing chkd APIs - create story via spec/add, epic via epic endpoint, etc.

**Key requirements:**
- POST /api/capture/push accepts extracted object
- Routes to correct API: spec/add for stories, epic endpoint for epics
- Returns created item ID and confirmation
- Handles duplicate detection
- Validates object before pushing

**Files to change:**
- src/routes/api/capture/push/+server.ts - Push endpoint
- src/lib/server/capture/router.ts - Route objects to correct APIs

**Testing:**
- Story pushes to spec/add correctly
- Epic creates via epic endpoint
- Bug creates via bug endpoint
- Win creates via quickwin endpoint
- Duplicates are detected and rejected

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [x] **BE.27 Screenshot capture** #stateless-review-service - Playwright headless browser - launch, navigate to URL, capture full-page screenshot, close browser

**Key requirements:**
- Launch Chromium headless via Playwright
- Navigate to provided URL, wait for network idle
- Capture full-page screenshot as PNG buffer
- If wireframePath is HTML, screenshot that too
- Close browser after capture (stateless)
- Configurable viewport size

**Files to change:**
- src/lib/server/review/screenshot.ts - Screenshot capture module
- src/lib/server/review/index.ts - Call screenshot in review flow

**Testing:**
- Screenshots a localhost URL correctly
- Handles external URLs
- HTML wireframe screenshots work
- Browser closes after each capture
- Timeout handling for slow pages

- [x] **BE.28 Claude API visual analysis** #stateless-review-service - Send screenshot + wireframe + scope to Claude API, get structured review feedback (matches, gaps, suggestions)

**Key requirements:**
- Send images to Claude API with vision capability
- Include scope/requirements in prompt
- Parse response into ReviewResult structure
- Handle cases: with wireframe, without wireframe
- Score calculation based on matches vs gaps

**Files to change:**
- src/lib/server/review/analyze.ts - Claude API integration
- src/lib/server/review/prompts.ts - Analysis prompts
- src/lib/server/review/index.ts - Call analyze after screenshot

**Testing:**
- Analysis returns structured ReviewResult
- Wireframe comparison identifies visual differences
- Scope-only review checks against requirements
- Score reflects match quality (0-100)

- [ ] **BE.29 HTTP endpoint** #stateless-review-service - POST /api/review-build endpoint - accepts {url, wireframe, scope}, returns feedback, process exits after response

**Key requirements:**
- Endpoint already created in SD.25 setup
- Wire up screenshot capture (BE.27) and analysis (BE.28)
- Return ReviewResult with matches, gaps, suggestions, score
- Error handling for invalid URLs, timeouts
- Optional: return screenshot in response for debugging

**Files to change:**
- src/routes/api/review-build/+server.ts - Wire up full flow
- src/lib/server/review/index.ts - Implement review() function

**Testing:**
- Full flow: URL â†’ screenshot â†’ analyze â†’ response
- Returns proper error for unreachable URLs
- Wireframe path validation (exists, correct format)
- Response time reasonable (<30s typical)

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.30 MCP tool integration** #stateless-review-service - Add chkd_review_build MCP tool - spawns review service as subprocess, waits for response, returns feedback to Claude

**Key requirements:**
- chkd_review_build MCP tool in server.ts
- Calls /api/review-build endpoint internally
- Returns formatted feedback for Claude consumption
- Error messages helpful for debugging
- Optional: include screenshot path in response

**Files to change:**
- src/mcp/server.ts - Add chkd_review_build tool
- Tool schema: url (required), wireframePath (optional), scope (required)

**Testing:**
- MCP tool returns ReviewResult correctly
- Error handling surfaces useful messages
- Works with and without wireframe
- Claude can use feedback to iterate on UI

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.31 Add Test workflow step after Implement** #workflow-quality-gates - Add new workflow step 'Test: run unit tests, fix failures' between Implement and Polish. Update DEFAULT_WORKFLOW_STEPS in writer.ts. All workflow types should include this step.

**Key requirements:**
- New workflow step: "Test: run unit tests, fix failures"
- Position: after Implement, before Polish
- Sub-tasks: "Run: execute test suite", "Fix: address any failures"
- Apply to all workflow types (default, backend, refactor, etc.)

**Files to change:**
- src/lib/server/spec/writer.ts - Add TEST_STEP to DEFAULT_WORKFLOW_STEPS
- src/cli/llm.ts - Update workflow prompts if needed

**Testing:**
- New stories include Test step in workflow
- Test step appears after Implement in spec output
- All workflow variants include Test step

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.32 Require Unit tests field in spec items** #workflow-quality-gates - Add 'Unit tests:' as required field alongside 'Key requirements:', 'Files to change:', 'Testing:'. Block chkd_working if field is TBC (like other required fields). Update chkd_add to prompt for unit tests.

**Key requirements:**
- Add "Unit tests:" section to spec item template
- Required field - cannot be TBC when starting work
- chkd_working blocks if Unit tests is TBC
- chkd_add MCP tool accepts unitTests parameter

**Files to change:**
- src/lib/server/spec/writer.ts - Add Unit tests to item template
- src/mcp/server.ts - Add unitTests param to chkd_add
- src/routes/api/spec/in-progress/+server.ts - Validate Unit tests not TBC

**Testing:**
- New items created with Unit tests section
- chkd_working fails if Unit tests is TBC
- chkd_add accepts and writes unitTests field

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote
- [ ] **BE.33 Refactor workflow with test-first approach** #workflow-quality-gates - New story type for refactoring existing code. Philosophy: ship working code first, log smells, tackle refactors later with strong tests. Tests lock in behavior BEFORE refactoring to prevent regressions.

**Key requirements:**
- New workflow type: "refactor" in writer.ts
- Steps: Explore â†’ Test (write tests first!) â†’ Refactor â†’ Verify â†’ Commit
- chkd_add supports type="refactor" parameter
- Refactor backlog: way to log "needs refactor" items during normal work
- Quality checklist: complexity, duplication, function size, magic numbers

**Files to change:**
- src/lib/server/spec/writer.ts - Add REFACTOR_WORKFLOW
- src/mcp/server.ts - Add type param to chkd_add
- Possibly chkd_refactor command to log refactor items

**Testing:**
- Refactor stories use test-first workflow
- Tests run before and after refactoring
- Quality checklist included in workflow

  - [ ] Explore > Research: investigate codebase, problem space, and any discovery docs
  - [ ] Explore > Questions: consider if clarification needed - ask user if unclear
  - [ ] Explore > Share: inform user of findings before continuing
  - [ ] Design > Draft: create initial design/approach
  - [ ] Design > Review: show user, iterate if needed
  - [ ] Prototype > Build: create the prototype
  - [ ] Prototype > Verify: compare to spec/wireframe, iterate if gaps
  - [ ] Feedback > Demo: show user the prototype
  - [ ] Feedback > Iterate: make changes based on feedback
  - [ ] Implement > Build: implement real logic
  - [ ] Implement > Verify: test functionality works
  - [ ] Polish > Consider: wider impact - error handling, input validation, edge cases
  - [ ] Polish > Review: trace through scenarios, check error paths work
  - [ ] Polish > Confirm: verify against discovery assumptions if any, show user findings, get approval
  - [ ] Document > Write: update relevant documentation
  - [ ] Document > Review: confirm docs match implementation
  - [ ] Commit > Stage: review changes, stage files
  - [ ] Commit > Commit: summary line (what), body (why + assumptions), push to remote

---

## Multi-Worker System

> Parallel Claude workers using git worktrees. Master Claude coordinates, workers execute.

### Phase 1: Foundation ðŸš§
- [x] **MW.1 Workers Database Schema** - Tables for workers, history, and signals

- [x] **MW.2 Git Worktree Utilities** - Create, remove, and manage worktrees

- [x] **MW.3 Worker API Endpoints** - CRUD for workers

### Phase 2: One-Click Spawning ðŸš§
- [x] **MW.4 Worker MCP Tools** - Master Claude spawns and manages workers

- [x] **MW.5 Worker Heartbeat System** - Workers report status

- [x] **MW.6 Enhanced Repo Card UI** - Show workers at high level

### Phase 3: Split Brain View & Auto-Merge
- [x] **MW.7 Split Brain View** - Side-by-side worker panels
  - [x] Current task + progress per worker
  - [x] Next in queue display
  - [ ] Recently touched files list (needs git integration)
  - [x] Pause/Stop/View Code actions

- [x] **MW.8 Manager Signal Bar** - Coordinator communication

- [x] **MW.9 Auto-Merge System** - Merge when safe, ask when not

### Phase 4: Manager as Tech Lead âœ…
- [x] **MW.10 Manager Research Mode** - Explore codebase before assigning work

- [x] **MW.11 Manager Story Writer** - Create detailed specs from user requests

- [x] **MW.12 Manager Code Review** - Review worker output before merge

- [x] **MW.13 Manager Documenter** - Update docs after work completes

### Phase 5: External Collaboration âœ…
- [x] **MW.14 External Story Submission** - Allow non-developers to submit feature ideas

> As a stakeholder/user, I want to submit feature ideas without needing to edit the spec directly, so that I can contribute ideas even if I'm not a developer.

### Future: SaaS Platform
- [x] **MW.15 SaaS Architecture** - Design for hosted multi-tenant platform

> As a team, we want a hosted chkd service so we don't need to run infrastructure ourselves.

---

## Future Areas

> Not yet started. Organized by what they'll touch.

### Quality Features (v3+)
- [ ] **FUT.1 Test Generation** - Auto-generate tests on commit (port from v1)
- [ ] **FUT.2 Sceptic Check** - Validate ideas before building
- [ ] **FUT.3 Quality Gates** - Block bad code from main
- [ ] **FUT.4 Code Health Checks** - Simple quality checks before/after tasks using jscpd (duplication) and knip (dead code). Integrate into Explore phase - flag issues, let user decide to refactor or proceed. Not a gate, just information.

> As a developer, I want code health checks before starting a task so I can decide whether to refactor first, and after finishing so I can log any new technical debt.
  - [ ] Explore: research problem, check existing code/patterns
  - [ ] Design: plan approach + define endpoint contracts
  - [ ] Prototype: build UI with mock data, stub backend
  - [ ] Feedback: user reviews and approves UX
  - [ ] Implement: connect real backend logic
  - [ ] Polish: error states, edge cases, performance

### Git & Source Control (UI owns this)
- [ ] **FUT.4 Diff View** - See what changed during session
- [ ] **FUT.5 Staging UI** - Select files to commit
- [ ] **FUT.6 Commit Flow** - Pre-fill message from session, commit
- [ ] **FUT.7 Push to Remote** - Push when ready
- [ ] **FUT.8 Audit Trail** - History of commits per session

### Advanced Features
- [ ] **FUT.9 WebSocket Updates** - Real-time UI updates
- [ ] **FUT.10 Version History** - Track spec changes over time
- [ ] **FUT.11 Create the best debug workflow and tool in the MCP ever created** - Create comprehensive debugging capabilities and workflow tools that surpass existing MCP debugging solutions.

> As a developer, I want powerful debug tools and workflows so that I can efficiently troubleshoot and resolve issues in the MCP system.
  - [ ] Explore: research existing MCP debug tools & pain points
  - [ ] Explore: audit current logging/error handling capabilities
  - [ ] Design: debug workflow + tool architecture/contracts
  - [ ] Prototype: core debug tools with mock error scenarios
  - [ ] Get feedback: test debug workflow with real issues
  - [ ] Implement: full debug toolset with enhanced logging
  - [ ] Polish: refine tools based on usage patterns
  - [ ] Document: debug workflow guide & tool reference

---

## Reference

### Workflow Template

Every feature added gets these 8 steps:
```
- [ ] Explore: research problem, check existing code/patterns
- [ ] Design: plan approach + define endpoint contracts
- [ ] Prototype: build UI with mock data, stub backend
- [ ] Feedback: user reviews and approves UX
- [ ] Implement: connect real backend logic
- [ ] Polish: error states, edge cases, performance
- [ ] Document: update docs, guides, and CLAUDE.md if needed
- [ ] Commit: commit code to git with clear message + assumptions
```

### Spec Format Rules

- Area header: `## Area Name` or `### Sub-Area`
- Section numbers: `**XX.N Feature Name**` (e.g., BE.1, FE.2)
- Checklist: `- [ ]` or `- [x]`
- User story: Blockquote `>`
- Status line: `**Status**: Complete/In Progress/Not started`

### Design Standards

- Colors: CSS variables (`--primary`, `--success`, etc.)
- Border radius: 6px inputs, 8px buttons, 12px cards
- Spacing: 4px base (4, 8, 12, 16, 24, 32)
- Status emoji: âœ… complete, ðŸš§ in-progress, ðŸ“‹ pending

### Code Standards

- Files: `kebab-case.ts`
- Classes: `PascalCase`
- Functions: `camelCase`
- API responses: `{ success, data?, error? }`

---

## Skills

Available Claude Code skills:

| Skill | Purpose |
|-------|---------|
| `/chkd` | Build mode - check session, implement tasks with polish |
| `/bugfix` | Fix bugs without feature creep - research first |
| `/story` | Develop stories - assess, question, refine specs |
| `/spec-check` | Validate SPEC.md format after editing |
